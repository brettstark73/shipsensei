import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth.config'
import { prisma } from '@/lib/prisma'
import { createRepository, createFiles } from '@/lib/github'
import {
  generateProjectTemplate,
  ProjectGenerationError,
} from '@/lib/project-generator'
import { validateGitHubAccess } from '@/lib/github-auth'

type RouteContext = {
  params: Promise<{ id: string }>
}

// POST /api/projects/[id]/generate - Generate project and create GitHub repo
export async function POST(request: NextRequest, context: RouteContext) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id: projectId } = await context.params

    // Securely validate GitHub access (never expose tokens to client)
    const githubAccess = await validateGitHubAccess(request)

    if (!githubAccess.hasAccess || !githubAccess.token) {
      return NextResponse.json(
        {
          error:
            githubAccess.error ||
            'GitHub access required. Please re-authenticate.',
        },
        { status: 400 }
      )
    }

    const accessToken = githubAccess.token

    // Verify project belongs to user
    const project = await prisma.project.findUnique({
      where: {
        id: projectId,
        userId: session.user.id,
      },
      include: {
        requirements: {
          orderBy: {
            order: 'asc',
          },
        },
      },
    })

    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Check if requirements are completed
    const answeredRequirements = project.requirements.filter(r => r.answer)

    if (answeredRequirements.length === 0) {
      return NextResponse.json(
        { error: 'No requirements completed' },
        { status: 400 }
      )
    }

    // Check if tech stack recommendation exists
    if (!project.techStack) {
      return NextResponse.json(
        { error: 'Tech stack recommendation required' },
        { status: 400 }
      )
    }

    // Update project status to generating
    await prisma.project.update({
      where: { id: projectId },
      data: { status: 'generating' },
    })

    try {
      // Generate repository name from project name
      const repoName = project.name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '')

      // Create GitHub repository
      const repo = await createRepository(
        accessToken,
        repoName,
        project.description || `Generated by ShipSensei: ${project.name}`,
        false // public by default
      )

      // Generate and validate project template
      const template = await generateProjectTemplate(
        project.name,
        project.description || '',
        answeredRequirements.map(r => ({
          question: r.question,
          answer: r.answer!,
        }))
      )

      // Create files in the repository
      await createFiles(accessToken, repo.owner, repoName, template.files)

      // Update project with repository info
      const updatedProject = await prisma.project.update({
        where: { id: projectId },
        data: {
          repository: repo.url,
          status: 'ready', // ready for deployment
        },
        include: {
          requirements: {
            orderBy: {
              order: 'asc',
            },
          },
        },
      })

      return NextResponse.json({
        message: 'Project generated successfully',
        project: updatedProject,
        repository: repo,
      })
    } catch (error) {
      // Revert status on error
      await prisma.project.update({
        where: { id: projectId },
        data: { status: 'ready' },
      })

      throw error
    }
  } catch (error) {
    console.error('Error generating project:', error)

    // Handle validation errors specifically
    if (error instanceof ProjectGenerationError) {
      return NextResponse.json(
        {
          error: 'Code validation failed',
          message: error.message,
          validationErrors: error.validationErrors,
          details:
            'The AI-generated code contains security vulnerabilities or quality issues',
        },
        { status: 400 }
      )
    }

    let errorMessage = 'Internal server error'

    if (error instanceof Error) {
      errorMessage = error.message
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 })
  }
}
